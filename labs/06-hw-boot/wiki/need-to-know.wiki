===== Need to know =====
// TODO update link
În [[http://ocw.cs.pub.ro/courses/uso/laboratoare/new/04 | secțiunea anterioară]]

==== Generarea de fișiere de dimensiune fixă folosind dispoztivie virtuale (dd) ====

În Linux putem folosi dispozitivele virtuale (ex. ''/dev/urandom'', ''/dev/random'', ''/dev/zero'') pentru a genera conținutul unui fișer nou.

<code bash>
student@uso:~$ cat /dev/urandom > dump
^C          # am oprit procesul corespunzător comenzii de mai sus trimițând semnalul SIGINT (Ctrl + c)
student@uso:~$ ls -lh dump
-rw-r--r-- 1 student student 281M oct 21 13:48 here
</code>

Comenzile de mai sus au avut ca efect generarea unui fișier cu conținut aleator (vezi ''/dev/urandom''), însă nu am putut controla dimensiunea noului fișier generat. Dimensiune fișierului generat variază în funcție de mai mulți parametri (ex. timp, viteză de scriere hdd/ssd, etc.).

Pentru a combate acest neajuns putem să folosim comanda ''dd''. ''dd'' poate primi un fișier de intrare (''in=<FILE>'') și un fișier de ieșire (''of=<FILE>''). De asemenea putem să controlăm dimensiunea fișierului pe care vrem să îl gemerăm cu ajutorum parametrilor ''bs=<BYTES>'' și ''count=<BLOCKS>''.

Astfel, dacă dorim să generăm un fișier cu dimensiunea de 100MB care să doar octeți egali cu zero, putem să folosim comanda:

<code bash>
student@uso:~$ dd if=/dev/zero of=dump bs=1M count=100
100+0 records in
100+0 records out
104857600 bytes (105 MB, 100 MiB) copied, 0,0832762 s, 1,3 GB/s
student@uso:~$ ls -lh dump 
-rw-r--r-- 1 student student 100M oct 21 14:07 dump
</code>

**Exerciții**
  - Să se genereze un fișier de dimensiune fixă (42 MB) care să conțină octeți aleatori. Dimensiunea unui block în cadrul comenzii ''dd'' trebuie să fie de 512 KB.
  - Să se genereze un fișier de dimensiune fixă (54 MB) care să conțină octeți aleatori. Numărul de block-uri în cadrul comenzii ''dd'' trebuie să fie egal cu 270.

==== Generarea de șiruri aleatoare folosind dispozitive virtuale  ====

Dispozitivele virtuale pot fi folosite pentru a genera parole aleatoare de dimensiune fixă.

<code bash>
student@uso:~$ head /dev/urandom | tr -dc A-Za-z0-9 | head -c 13 ; echo ''
P2wVwebdFFfcd
</code>

Am văzut, în cadrul exercițiilor anterioare, că putem genera octeți aleatori prin simpla citire a fișierului ''/dev/random''. Pentru a filtra caracterele nedorite am folosit comanda ''tr''(translate) alături de ''-dc'' (d - delete, c - complement). Comanda ''echo'' de la final are rolul de a afișa caracterul ''newline - \n''.

**Exerciții**
  - Generați o parolă formată doar din cifre cu lungimea de 14 caractere folosind dispoozitivele virtuale.

==== Identificare driverelor ====
În lumea Linux, implementarea unui driver (device driver) se face sub forma unei entități cu denumire de ''modul''. Un ''modul'' oferă posibilitatea de a adăuga diferite funcționalități peste kernelul unui OS (ex. folosirea unui dispozitiv specializat pentru calcul grafic - GPU). Astfel, un driver rulează în cadrul unui kernel, având acces la modul privilegiat și putând fi încărcat la cerere.

Pentru a identifica toate modulele din cadrul unui kernel Linux putem să folosim comanda ''lsmod''.

<code bash>
student@uso:~$ lsmod
Module                  Size  Used by
btrfs                1126400  0
zstd_compress         163840  1 btrfs
xor                    24576  1 btrfs
raid6_pq              114688  1 btrfs
ufs                    77824  0
qnx4                   16384  0
hfsplus               106496  0
hfs                    57344  0
minix                  32768  0
[...]
</code>

Pentru a afla mai multe informații de spre un modul putem folosi comanda ''modinfo''

<code bash>
student@uso:~$ modinfo ip_tables
filename:       /lib/modules/4.15.0-34-generic/kernel/net/ipv4/netfilter/ip_tables.ko
description:    IPv4 packet filter
author:         Netfilter Core Team <coreteam@netfilter.org>
license:        GPL
srcversion:     E73E003BA6D5C96B0DD463D
depends:        x_tables
retpoline:      Y
intree:         Y
name:           ip_tables
vermagic:       4.15.0-34-generic SMP mod_unload 
signat:         PKCS#7
signer:         
sig_key:        
sig_hashalgo:   md4
</code>

**Exerciții**
  - Identificați un modul ce implementează o interfață de rețea și afișați detalii despre acesta. (hint: ''e1000'').


==== Identificarea serviciilor ce rulează într-un sistem ====

<code bash>
student@uso:~$ systemctl list-unit-files --type=service
UNIT FILE                                  STATE
accounts-daemon.service                    enabled
acpid.service                              disabled
alsa-restore.service                       static
alsa-state.service                         static
alsa-utils.service                         masked
anacron.service                            enabled
apache-htcacheclean.service                disabled
apache-htcacheclean@.service               disabled
apache2.service                            enabled
[...]
</code>


Pentru a afla statusul unui serviciu putem folosi:

<code bash>
student@uso:~$ systemctl status dbus.service
● dbus.service - D-Bus System Message Bus
   Loaded: loaded (/lib/systemd/system/dbus.service; static; vendor preset: enabled)
   Active: active (running) since Mon 2018-10-15 16:10:25 EEST; 6 days ago
     Docs: man:dbus-daemon(1)
 Main PID: 555 (dbus-daemon)
    Tasks: 1 (limit: 2321)
   CGroup: /system.slice/dbus.service
           └─555 /usr/bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation --syslog-only

</code>

**Exerciții**
  - Afișați statusul serviciului ''network.service''
  - Afișați toate procesele care se află în starea ''enabled'' folosind doar comanda systemctl (hint: "--state")