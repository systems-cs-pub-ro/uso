===== Demo =====

Atunci când executăm comenzi în terminal, shell-ul crează câte un proces pentru fiecare comandă 
executată, proces care va fi copilul procesului curent (adică procesul aferent terminalului curent). 

<code bash>
student@uso:/uso.git/$ sleep 100 &
student@uso:/uso.git/$ ps -o pid,ppid,cmd
TODO output
</code>

<note> 
Observăm faptul că PPID-ul procesului este același cu PID-ul procesului ''bash'' din lista de mai sus. 
Acest lucru ne demonstrează faptul că procesul ''sleep'' este un proces separat față de terminalul curent 
și mai mult, este copilul acestuia. (TODO fix exprimare)
</note>

==== Comunicarea interprocese, pipe (|) ====
Să ne reamintim de la laboratorul 2 (TODO link) ce înseamnă comunicarea interprocese. Vrem ca rezultatele 
primei comenzi (datele de ieșire) să joace rolul de date de intrare pentru o a doua comandă. Pentru a realiza 
acest lucru folosim operatorul ''|''.

<code bash>
student@uso:/uso.git/$ TODO exemplu
</code>

==== Exit code ====
Orice proces care rulează în sistem se poate termina fie cu ''SUCCES'', fie cu ''EROARE''. Pentru a verifica 
dacă un proces s-a terminat sau nu cu succes, putem inspecta valoarea variabilei speciale ''$?''.

<code bash>
student@uso:/uso.git/$ ls
TODO output
student@uso:/uso.git/$ echo $?
0
student@uso:/uso.git/$ ping 192.12.12.1
TODO output
student@uso:/uso.git/$ echo $?
2
</code>

<note>
Codul ''0'' ne spune că procesul s-a terminat cu succes, iar orice altceva reprezintă un cod de eroare.
</note>

==== Înlănțuirea mai multor comenzi ====
În linia de comandă avem posibilitatea de a scrie o singură comandă care să execute, de fapt, mai multe 
procese unul după altul, indepenedente unul față de celelalte. Folosim operatorul '';'' pentru a înlănțui 
2 comenzi.

<code bash>
student@uso:/uso.git/$ TODO exemplu
</code>

==== Execuția mai multor procese ====
De multe ori putem avea o situație în care 2 procese depind unul de celălalt. Pentru a realiza acest 
lucru folosim operatorul ''&&'' care ne asigură faptul că a doua comandă se va executa doar în cazul în 
care prima se execută cu succes.

<code bash>
student@uso:/uso.git/$ cd TODO
student@uso:/uso.git/$ ls
TODO output
student@uso:/uso.git/$ cat my_nonexisting_file.txt && ls
TODO output
student@uso:/uso.git/$ echo $?
1
</code>

Observăm faptul că fișierul ''my_file.txt'' nu există și faptul că a doua comandă nu se mai execută, exact 
ce am dorit să arătăm.

Schimbăm puțin abordarea astfel încât ambele comenzi să fie executate.

<code bash>
student@uso:/uso.git/$ cd TODO
student@uso:/uso.git/$ ls
TODO output
student@uso:/uso.git/$ cat my_existing_file.txt && ls
TODO output
student@uso:/uso.git/$ echo $?
0
</code>

Situația opusă pe care o putem întâlni este să vrem să executăm o a doua comandă doar dacă prima nu s-a 
terminat cu succes. Pentru a face acest lucru folosim operatorul ''||'' (sau logic). 

<code bash>
student@uso:/uso.git/$ cd TODO
student@uso:/uso.git/$ ls
TODO output
student@uso:/uso.git/$ cat my_nonexisting_file.txt && ls
TODO output
</code>

În cazul operatorului ''||'', a doua comandă nu se va executa dacă prima se termină cu succes.

<code bash>
student@uso:/uso.git/$ cd TODO
student@uso:/uso.git/$ ls
TODO output
student@uso:/uso.git/$ cat my_existing_file.txt && ls
TODO output
</code>

==== Subshell ====
Atunci când folosim operatorii shell putem dori să operăm asupra unei compoziții de comenzi. 
De exemplu dorim să reținem output-ul a două comenzi într-un fișier. La o rulare precum cea de mai 
jos nu funcționează:

<code bash>
student@uso:~/uso.git/$ ls ; ps > out
TODO output
student@uso:~/uso.git/$ cat out
TODO output
</code>

Observăm că doar rezultatul rulării comenzii ps este redirectat. Pentru a redirecta o înlănțuire de 
comenzi folosim un subshell, adică vom crea un proces nou shell care va rula cele două comenzi și va 
transfera rezultatul amândurora în fișier. Un subshell este creat cu ajutorul parantezelor la fel ca 
mai jos:

<code bash>
student@uso:~/uso.git/$ ( ls ; ps ) > output2
student@uso:~/uso.git/$ cat output2
TODO output
</code>

În acest al doilea caz, se vede că ambele rezultate sunt redirecționate în același fișier ''output2''.

==== Globbing ====
În cazul în care vrem să afișăm toate fișierele ale căror nume încep cu litera ''a'' și au extensia 
''.txt'', putem folosi ''globbing''. Simbolul ''*'' este un wilecard și ține locul pentru **orice 
de oricâte ori**.

<code bash>
student@uso:~/uso.git/$ cd TODO
student@uso:~/uso.git/$ ls a*.txt
TODO output
</code>

==== Expandări ====
După ce un shell primește comenzile, parametrii și operatorii de la intrare, și după ce îi separă, 
realizează operațiile de expandare.
Expandarea de acolade înseamnă trecerea prin mai multe opțiuni. De exemplu:

<code bash>
student@uso:~/uso.git/$ cd TODO
student@uso:~/uso.git/$ ls {TODO}.txt
TODO output
</code>

Știm că simbolul ''~'' ține locul directorului home al utilizatorului curent. Atunci când rulăm 
comanda ''cd ~'', tilda este înlocuită cu valoarea variabilei HOME a shell-ului curent.

<code bash>
student@uso:~/uso.git/$ cd ~
student@uso:~/uso.git/$ pwd
TODO output
student@uso:~/uso.git/$ echo $HOME
/home/student
</code>

Expandarea parametrică se referă la construcții care încep cu ''${''. Cea mai simplă formă este chiar 
expandarea valorii unei variabile:

<code bash>
student@uso:~/uso.git/$ mouse="Jerry"
student@uso:~/uso.git/$ echo ${mouse}
Jerry
</code>

Comanda de mai sus este echivalentă cu ''echo $mouse'', însă alcoladele devin utile în momentul în 
care vrem să afișăm valoarea unei variabile urmate de un șir.

<code bash>
student@uso:~/uso.git/$ mouse="Jerry"
student@uso:~/uso.git/$ echo $mouse_the_best
TODO output
</code>

Shell-ul va încerca în acest caz să afișeze valoare variabilei ''mouse_the_best'' care, în cazul nostru, 
nu există. Pentru a rezolva această problemă, folosim acoladele să specficăm de unde până unde ne referim 
la un nume de variabilă.

<code bash>
student@uso:~/uso.git/$ mouse="Jerry"
student@uso:~/uso.git/$ echo ${mouse}_the_best
Jerry_the_best
</code>

Un alt caz în care expandarea este utilă este evaluarea expresiilor aritmetice. Pentru început, declarăm 2 
variabile propii în shell:

<code bash>
student@uso:~/uso.git/$ a=3
student@uso:~/uso.git/$ b=4
student@uso:~/uso.git/$ echo $a && echo $b
3
4
</code>

Dacă vrem să evaluam valoarea expresiei ''a+b'', trebuie să folosim următoarea construcție:

<code bash>
student@uso:~/uso.git/$ echo $((a+b))
7
</code>

<note>
Dacă am fi folosit comanda ''echo $a+$b'', shell-ul ar fi înlocuit ''$a'' cu valoarea lui a, adică ''3'' 
și ''$b'' cu valoarea lui b, adică ''4'', iar rezultatul comenzii va fi ''3+4'', nu ''7'' așa cum ne-am fi 
așteptat.
</note>

==== Variabile de mediu ====
Pentru a lista toate variabilele de mediu folosite de terminalul curent, folosim comanda ''env''.

<code bash>
student@uso:/uso.git/$ env
TODO output
</code>

O variabilă de mediu foarte importantă și destul de des folosită este variabila de mediu ''PATH''.
Ea conține mai multe căi în care se caută binarele din sistem, cum ar fi ''ls''.



